---
title: Sudoku!
description: 'an algorithm that completes sudokus'
date: January 31 2023

---

![sudoku img](data:image/png;base64,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)


##a little introduction, good morning good morning

---

## Problem Solving

Sudoku is a puzzle game where you fill in a 9x9 grid with numbers so that each row, column, and 3x3 section contain all of the digits from 1 to 9. The goal is to fill in the grid so that there are no repeating numbers in any row, column, or section. 
To play, the most popular way is to start by looking for empty squares with the fewest possible options for the number that can be placed there. Then, use logic to eliminate possibilities and fill in the square. This process will be repeated until the entire grid is filled in. 
_Anyway_
An efficiant algorithm should be oriented towards that, but in a more strict way. Time and space complexity as well as Scalability won't have a big impact, because in most cases the input will be a 9x9 array, so we can neglect that and focus on Readability and maintainability of the code and most important: Accurany!

---

## The code implemented in python

I'd like to start with the main method, before we get to the help method. The goal is to get through a 9 row x 9 col array (= input) and fill in the missing numbers in a correct way. 
To check every spot in the array we need to implement two for loops and in every position arr[row_i][col_i] we check if the value is unoccupied (= 0). 
If there is one a third for loop starts with the goal to fill in the right value (= num) for every unoccupied value (= arr[row_i][col_i]). 
First we check if the potential right value can be placed in the unoccupied field (is_num_possible(row_i, col_i, num, arr)). If that is so, the unoccupied spot is now occupied (with num) and the recursion starts. 
Its most likely that the first num that was filled in isn't the right one. So in the recursion the programm finds no number 1-9 that can be placed in the free spot. Now the recursion returns and the current position will be unocuppied for now. The algortihm returns to the latest number it filled in and tries another number for the spot. More general you could say it checks every possibility in an ordered sequence. Only if every spot has been taken, the algorithm will skip the third for loop and returns the first solution (or print the sudoku).

```js
def solve_sudoku(arr):
    for row_i in range(9):
        for col_i in range(9):
            if arr[row_i][col_i] == 0:
                for num in range(1, 10):
                    if is_num_possible(row_i, col_i, num, arr):
                        arr[row_i][col_i] = num
                        solve_sudoku(arr)
                        arr[row_i][col_i] = 0
                return
    print_sudoku(arr)
```


This is the part, where a paper and a pencil helps for sure. As an input we get the current position (row, col) we would like to fill an certain number (= num) in.
You can split the method in three parts, whenever any part returns False, the method ends. First we check if any number in the same col equals our num. If not we keep going and check the exect same think with the numbers in the same row. If there is no match we can keep going and come to the last part. 
In this part we determine the first spot in the 3x3 section. This is the starting point of a double for loop in which we check if any of the numbers in the section is equal to our input. If not we can safely return true :) 

```js
def is_num_possible(row, col, num, arr):
    for row_i in range(9):
        if arr[row_i][col] is num:
            return False
    for col_i in range(9):
        if arr[row][col_i] is num:
            return False
    upper_left_row = (row // 3) * 3
    upper_left_col = (col // 3) * 3
    for row_i in range(3):
        for col_i in range(3):
            if arr[upper_left_row + row_i][upper_left_col + col_i] == num:
                return False
    return True
```

---
| Input                | Output               |
| -------------------: | -------------------: |
|0 0 0 / 0 0 7 / 0 3 0 | 2 1 4 / 5 8 7 / 9 3 6| 
|0 0 0 / 0 0 0 / 5 0 0 | 3 7 6 / 1 9 4 / 5 8 2| 
|0 5 9 / 0 0 2 / 7 0 0 | 8 5 9 / 6 3 2 / 7 4 1|
|                      |                      |
|1 0 0 / 4 0 0 / 0 0 8 | 1 9 7 / 4 6 3 / 2 5 8|
|0 2 0 / 0 0 5 / 0 0 0 | 6 2 8 / 7 1 5 / 4 9 3|
|0 4 3 / 8 0 0 / 0 6 0 | 5 4 3 / 8 2 9 / 1 6 7|
|                      |                      |
|9 3 0 / 0 0 0 / 0 0 0 | 9 3 1 / 2 5 8 / 6 7 4|
|0 0 0 / 0 7 0 / 8 2 0 | 4 6 5 / 3 7 1 / 8 2 9|
|0 8 0 / 9 4 0 / 0 0 5 | 7 8 2 / 9 4 6 / 3 1 5|

---

## Outlook

Due to my health informatics studys i wanted to get used to OpenCV and this project seems like a good fit. As an input i want an image of a sudoku. A method should transform this picture to a 2d array which can be solved with the descriped algorithm. Right now the only way to implement this method is with the help of ML and this is completely new to me. It will take some time to get used to the concept and find a model that fits or create an own.   
